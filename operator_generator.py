import pathlib

def fix_name(name):
    new_name = name.replace(" ", "_")
    new_name = new_name.replace("\\", "_")
    new_name = new_name.replace("/", "_")
    return new_name

def generate_class_string(obj, add_properties_callbacks):
    
    primitive_type = obj.name.split(".")[0]
    primitive_type = primitive_type.split("_")[1:]
    primitive_type = "_".join(primitive_type)
    class_name = f'PRIMITIVO_OT_{primitive_type}_Add'
    s = f'\nclass {class_name}(bpy.types.Operator, operators.PRIMITIVO_OP_Add):\n'
        
    primitive_type_lower = primitive_type.lower()
    s += f'''    """Adds a procedural {primitive_type.replace("_", " ")} object to the scene"""
    bl_idname = 'mesh.primitivo_{primitive_type_lower}_add'
    bl_label = "Primitivo {primitive_type}"
    bl_options = {{'REGISTER', 'UNDO' }}

    primitivo_type = 'Primitivo_{primitive_type}'
    auto_smooth_angle = {obj.data.auto_smooth_angle}
    
    '''
    
    if add_properties_callbacks:
        s = properties_callbacks(s, obj)
    
    return class_name, s

def properties_callbacks(s, obj):
    modifier = obj.modifiers[0]

    s += '''    def update_props(self, context): 
        modifier = bpy.context.active_object.modifiers[0]\n'''
        
    for input in modifier.node_group.inputs:
        if input.identifier == 'Input_0': continue
    
        name = fix_name(input.name)     

        if input.type == 'VECTOR':
            s +=  f"        modifier['{input.identifier}'][0] = self.{name}[0]\n"
            s +=  f"        modifier['{input.identifier}'][1] = self.{name}[1]\n"
            s +=  f"        modifier['{input.identifier}'][2] = self.{name}[2]\n"
        elif input.type in {'INT', 'VALUE', 'BOOLEAN'}: 
            s +=  f"        modifier['{input.identifier}'] = self.{name}\n"
        else:
            print(f'input type not implemented: { input.type}')
        
    s += "\n"

    for input in modifier.node_group.inputs:
        if input.identifier == 'Input_0': continue
      
        name = fix_name(input.name)     
        if input.type == 'INT':            
            s += f'''    {name}: IntProperty(name='{input.name}', default={input.default_value}, 
            min={input.min_value}, max={input.max_value}, update=update_props)\n'''
        elif input.type == 'VALUE':            
            s += f'''    {name}: FloatProperty(name='{input.name}', default={input.default_value}, 
            min={input.min_value}, max={input.max_value}, update=update_props)\n'''
        elif input.type == 'VECTOR':
            s += f'''    {name}: FloatVectorProperty(name='{input.name}', default={input.default_value.to_tuple()}, 
            size=3, unit='LENGTH', subtype='XYZ', min={input.min_value}, max={input.max_value}, update=update_props)\n'''
        elif input.type == 'BOOLEAN':            
            s += f'''    {name}: BoolProperty(name='{input.name}', default={input.default_value}, update=update_props)\n'''
        else:
            print(f'input type not implemented: { input.type}')
        
    s += "\n"


    s += '''    def draw(self, context):
        layout = self.layout
        layout.use_property_split = True
        layout.use_property_decorate = False\n\n'''

    for input in modifier.node_group.inputs:
        if input.identifier == 'Input_0': continue
      
        name = fix_name(input.name)     
       
        s += f'        layout.prop(self, "{name}")\n'

    s += '\n        super().draw(context)\n'

    return s

def run(objects, destination):

    print("-" * 66)

    to_register_list = "\nclasses = (\n"
    classes = []

    for obj in objects:
        if not obj.name.startswith('Primitivo_'): continue

        name, class_string = generate_class_string(obj, False)
        print(name)
        classes.append(class_string)
        to_register_list += f"    {name},\n"

    to_register_list += ")\n\n"

    print(f"writing to: {str(destination)}")
    with open(destination,'w',encoding="UTF-8") as file:

        file.write('''
# This file is generated by operator_generator.py
# Do not edit manually 

import bpy

from bpy.props import (
StringProperty,
BoolProperty,
IntProperty,
FloatProperty,
FloatVectorProperty,
EnumProperty,
)

from . import operators
''')

        for c in classes:
            file.write(c)        

        file.write(to_register_list)
        file.write('''
def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
''')